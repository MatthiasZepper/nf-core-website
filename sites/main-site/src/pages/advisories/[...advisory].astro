---
import MarkdownTocLayout from "@layouts/MarkdownTocLayout.astro";
import { getCollection, render } from "astro:content";
import type { CollectionEntry } from "astro:content";
import type { SidebarEntry } from "@utils/types";
import { createLinkOrGroup } from "@utils/functions";

export async function getStaticPaths() {
    const advisories = await getCollection("advisories");
    return advisories.map((advisory) => ({
        params: {
            advisory: advisory.id.replace(/\.[^/.]+$/, ""),
        },
        props: {
            advisory: advisory,
            advisories: advisories,
        },
    }));
}
const { advisory, advisories } = Astro.props;
const title = advisory.data.title;
const subtitle = advisory.data.subtitle;
let frontmatter = advisory.data;
const { headings, Content } = await render(advisory);

const md_github_url =
    "https://github.com/nf-core/website/blob/main/sites/main-site/src/content/advisories/" + advisory.id + ".md";

const addEntriesToSection = (sections, advisories: CollectionEntry<"advisories">[]) => {
    advisories.forEach((advisory) => {
        const parts = advisory.id.replace(/\.[^/.]+$/, "").split("/");
        let currentLevel = sections;

        parts.forEach((part, i) => {
            part = part.replaceAll("_", " ").replace(/(^)\S/g, (match) => match.toUpperCase());
            const existingEntry = currentLevel.find(
                (entry) => entry.label === part || entry.label === advisory.data.title,
            );

            if (existingEntry) {
                if (existingEntry.type === "group") {
                    // workaround for index files in nested advisories, where another element could already have created the group
                    if (/index\.(md|mdx)$/.test(advisory.id) && i === parts.length - 1) {
                        existingEntry.href = "/advisories/" + advisory.id.replace(/\.[^/.]+$/, "");
                        existingEntry.isCurrent = Astro.url.pathname === "/advisories/" + advisory.id.replace(/\.[^/.]+$/, "");
                        existingEntry.collapsed = Astro.url.pathname === "/advisories/" + advisory.id.replace(/\.[^/.]+$/, "");
                    }
                    currentLevel = existingEntry.entries;
                }
            } else {
                const lastPart = i === parts.length - 1;
                let title = lastPart ? (advisory.data.shortTitle ?? advisory.data.title) : part;
                const newEntry = createLinkOrGroup(
                    parts.slice(0, i + 1).join("_"),
                    title,
                    "/advisories/" + advisory.id.replace(/\.[^/.]+$/, ""),
                    lastPart,
                    Astro.url.pathname,
                );
                currentLevel.push(newEntry);

                if (newEntry.type === "group" && newEntry.entries) {
                    currentLevel = newEntry.entries;
                }
            }
        });
    });
};
const years = [...new Set(advisories.map((advisory) => advisory.data.publishedDate.getFullYear()))].sort((a, b) => b - a);
let sections: SidebarEntry[] = years.map((year) => {
    return {
        id: year.toString(),
        label: year.toString(),
        entries: [],
        type: "group",
        collapsed: true,
    };
});
addEntriesToSection(sections, advisories);
// sort .entries by date
sections.forEach((year) => {
    year.entries.sort((a, b) => {
        const advisoryA = advisories.find((advisory) => "/advisories/" + advisory.id.replace(/\.[^/.]+$/, "") === a.href);
        const advisoryB = advisories.find((advisory) => "/advisories/" + advisory.id.replace(/\.[^/.]+$/, "") === b.href);
        return advisoryB.data.publishedDate.getTime() - advisoryA.data.publishedDate.getTime();
    });
});
---

{frontmatter.importTypeform && <script type="text/javascript" src="https://embed.typeform.com/next/embed.js" async />}
<MarkdownTocLayout
    title={title}
    subtitle={subtitle}
    md_github_url={md_github_url}
    advisory_header={frontmatter}
    headings={headings}
    sections={sections}
    leftSidebar={true}
    docSearchTags={[
        { name: "page_type", content: "advisory" },
        ...frontmatter.type.map(type => ({ name: "page_subtype", content: type }))
    ]}
    viewTransitions={true}
>
    <Content />
</MarkdownTocLayout>
